#' Eliot Dixon, Ashton Drew
#' KDV Decision Analysis LLC
#' Spring 2020

library(sf)
library(urltools)
library(mapview)
library(stringr)
library(mapview)

#' Abbreviates refuge name
#' 
#' @param refugeName: char, refuge nam
createNameAbbrev <- function(refugeName){
  return(str_replace_all(str_to_title(refugeName), pattern=" ", repl=""))
}


#' Check to see if warning indicates result directory couldn't be created
#' 
#' @param warning: warnings generated by call to st_write()
#' TODO: Needs wider use cases to cover other potential warnings/errors
isWriteWarning <- function(warning){
  warningText <- conditionMessage(warning)
  dirWarning <- "cannot create dir"
  return(grepl(dirWarning, warningText, fixed=TRUE))
}


#' Write refuge data to a given location
#' 
#' @param dat: sf, refuge data obtained from FWS Rest API
#' @param refugeName: char, Name of given refuge
#' @param resultsFolder: char, Path to a location in which to store refuge data
#' TODO: Add code to catch errors when trying to create result folder, hide warnings generated by st_write(),
##' if .shp already exists should it automatically be overwritten?
writeFWSCadastral <- function(dat, refugeName, resultsFolder){
  refugeAbbrev <- createNameAbbrev(refugeName)  
  resultsPath <- sprintf("%s/%s",resultsFolder,refugeAbbrev)
  if(is.null(resultsFolder)){
    print("Please provide a path to folder in which to store results")
    return(dat)
  }
  else if(dir.exists(resultsFolder)) {         #if dir exists
    if(file.access(resultsFolder,2) == 0){    #if R has write permissions
      dir.create(file.path(resultsPath))
      st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", 
                            resultsPath, refugeAbbrev), delete_dsn=TRUE, quiet = TRUE)   
    }
    else{
      print(sprintf("This program does not have permission to write to %s",resultsFolder))
    }
  }
  else{       #if dir doesn't exist
    tryCatch({
      dir.create(file.path(resultsFolder))
      dir.create(file.path(resultsPath))
    },
    warning = function(w){
      if(isWriteWarning(w)){ 
        print(sprintf("Cannot create/access '%s', please check provided path", resultsFolder))
        do.call(return, list(NULL),envir = sys.frame(-4)) #return to getFWSCadastral
      }
    })
    st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", 
                          resultsPath, refugeAbbrev), delete_dsn=TRUE, quiet = TRUE)  
  }
  
}#Write FWSCadastral


#' Obtain refuge data from FWS Rest API
#' 
#' @param refugeName: char, Name of desired refuge
#' @param writeResult: boolean, describes whether or not to store obtained data
#' @param resultsFolder: char, path to folder in which to store obtained data
#' TODO: Include check for time out(ie FSW servers are down)
##' Determine how to handle layerName parameter, and how the layers from .gdb relate to variables in data from Rest API
getFWSCadastral <- function(refugeName, writeResult=FALSE, resultsFolder=NULL){
  if(nchar(refugeName) < 1){ #generate url to query DB
    print("Please provide a valid refuge name")
    return(NULL)
  }
  baseUrl <- readLines("base_URL.txt")
  url <- param_set(baseUrl[1], key = "where", value = sprintf("ORGNAME+LIKE+'%s%%25'",gsub(" ","+",refugeName)))
  dat <- read_sf(url)    #query db and read into sf obj
  if(nrow(dat)==0| is.null(dat)){
    print("No data returned for this request, please check provided refuge name")
  }
  else{
    if(writeResult == TRUE){
      writeFWSCadastral(dat, refugeName,resultsFolder)
    }
    return(dat)
  }
  
}#getFWSCadastral

#troubleshooting function
checkPlot <- function(huc, focalSf){
  leaflet() %>%
    addProviderTiles("Esri.WorldStreetMap", group="Map") %>%
    addProviderTiles("Esri.WorldImagery", group="Image") %>%
    addPolygons(data = as_Spatial(focalSf), stroke=F,fillColor="cyan",fillOpacity=0.7, group="Refuge") %>%
    addPolygons(data=as_Spatial(huc), fill=F, color="goldenrod",
                opacity=0.8, group="HUC")
}

#troubleshooting function
writeData <- function(huc,focalSf){
  st_write(huc,"C:/Users/Eliot/Desktop/ScratchData/huc.shp")
  st_write(focalSf,"C:/Users/Eliot/Desktop/ScratchData/focalSf.shp")
}


#' Obtain intersecting huc8 or huc10 waterbody from USGS Rest API
#' 
#' @param hucLayer: String dictating whether to get huc8 or huc10
#' @param focalSf: Shape file containing site which to obtain interecting waterbodies
#' TODO: Lot's of testing, attempt to find way to query API with polygon rather than
#'       bounding box to remove need to filter out excess HUCs
getHucs <- function(hucLayer, focalSf){
  baseUrl <- read_lines("Base_URL.txt")
  bbox <- toString(st_bbox(focalSf))
  epsg <- st_crs(focalSf)$epsg
  
  if(hucLayer == "WBDHU8"){
    url <- baseUrl[2]
  }
  else if (hucLayer == "WBDHU10"){
    url <- baseUrl[3]
  }
  
  url <- param_set(url, key ="geometry", value = URLencode(bbox)) %>%
    param_set(key = "inSR", value = epsg) %>%
    param_set(key = "outSR", value = epsg)

  huc <- read_sf(url)
  huc <- dplyr::filter(huc, lengths(st_intersects(huc,focalSf))>0)
 
  return(huc)
}






returnHuc <- getHucs("WBDHU8", dat1)
checkPlot(returnHuc, dat1)

dat1 <- getFWSCadastral("IRON RIVER NATIONAL FISH HATCHERY")
dat2 <- getFWSCadastral("CAMERON PRAIRIE NATIONAL WILDLIFE REFUGE")
dat3 <- getFWSCadastral("grasslands")
dat <- getFWSCadastral()

bbox <- st_bbox(dat3)





#--------------------------------Spare code below--------------------------------------------------

#old version
getFWSCadastral_old <- function(dataDSN, layerName, refugeName, writeResult=FALSE, resultsFolder=NULL){
  # Get current approved boundary
  dat <- read_sf(dsn=dataDSN, layer=layerName)
  if (nrow(dat)==0| is.null(dat)){
    print("No data returned for this data request.  Check the file and layer names.")
  } else {
    dat <- dplyr::filter(dat, grepl(refugeName, ORGNAME) & RSL_TYPE=="NWR")
    refugeAbbrev <- createNameAbbrev(refugeName)
    
    if (writeResult==TRUE){
      if(is.null(resultsFolder)){
        print("Please provide a path to folder in which to store results")
      }
      else if(!dir.exists(resultsFolder)) {
        dir.create(file.path(resultsFolder))
      }
      st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", 
                            resultsFolder, refugeAbbrev), delete_dsn=TRUE)
    }
    
    
  }
  return(dat)
}


dsn <- "C:/Users/Eliot/Desktop/Documents/KDV_Decisions/FWS_Proj/Data/GeoDB/FWSCadastral.gdb"
refuge_name <- "TIJUANA SLOUGH NATIONAL WILDLIFE REFUGE" 
layer_name <- "FWSApproved"

cad_data <- getFWSCadastral_old(dsn, layer_name, refuge_name, writeResult = TRUE, resultsFolder = "G:/fake")









#' Write refuge data to a given location
#' 
#' @param dat: sf, refuge data obtained from FWS Rest API
#' @param refugeName: char, Name of given refuge
#' @param resultsFolder: char, Path to a location in which to store refuge data
#' TODO: Find more direct way to handle generated from call warnings/errors to st_write() 
##' Cleaner way to determine if write was successful
##' Eliminate redundant calls to st_write()
##' Further testing regarding provided file paths
writeFWSCadastral_old <- function(dat, refugeName, resultsFolder){
  refugeAbbrev <- createNameAbbrev(refugeName)
  #Attempt to write to provided path
  tryCatch({
    if(is.null(resultsFolder)){
      print("Please provide a path to folder in which to store results")
      return()
    }
    else if(!dir.exists(resultsFolder)) {
      dir.create(file.path(resultsFolder))
    }
    st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp",   #Issue *1, this call alwas generates warnings
                          resultsFolder, refugeAbbrev), delete_dsn=TRUE, quiet = TRUE)        
  },
  #Catch warnings, use to determine if output files can be written
  warning = function(w){    #issue *1 Therefor this section will always fire                                                          
    if(isWriteWarning(w)){                                                                   
      print(sprintf("Cannot create/access '%s', please check provided path", resultsFolder)) 
    }
    else{
      st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", #issue *1 and this call still produces warnings 
                            resultsFolder, refugeAbbrev), delete_dsn=TRUE, quiet = TRUE)
    }
  })
  
}








