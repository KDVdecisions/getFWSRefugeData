setClass(
  Class="SiteData",
  representation(nwisSites="sf",
                 wqpSites="sf",
                 availableNwisData="data.frame",
                 availableWqpData="data.frame")
)

#'creates SiteData object which contains relevant NWIS and WQP data about a requested site
#'
#'@param baseData: sf object containing base geometry for requested site
#'@param NWIS: Logical indicating whether NWIS data should be included
#'@param WQP: Logical indicating whether WQP data should be included
#'@param buffer: Logical indicating whether the bounding box should be constructed from a buffered base geometry
#'
createSiteObject <- function(baseData, NWIS, WQP, buffer=FALSE){
  if(buffer){
    siteBuffer  <- st_as_sf(st_buffer(st_union(baseData), dist=0.01))
    boundingBox <- getBoundingBox(siteBuffer, epsg=4269)  
  }
  else{
    siteBuffer <- NULL
    boundingBox <- getBoundingBox(baseData, epsg=4269)
  }
  #instantiate new SiteData object
  site <- new("SiteData")
  
  if(NWIS){
    #obtain NWIS data
    nwisSites <- getSites(source="NWIS", focalSf=baseData, bufferSf=siteBuffer,
                         bbox=boundingBox, epsg=4269)
    availableNwisData <- whatNWISdata(siteNumber=nwisSites$site_no)
    #assign nwis data and sites to SiteData object
    site@nwisSites <- nwisSites
    site@availableNwisData <- availableNwisData
  }
 
  if(WQP){
    #obtain WQP data
    wqpSites <- getSites(source="WQP", focalSf=baseData, bufferSf=siteBuffer,
                        bbox=boundingBox, epsg=4269)
    availableWqpData <- whatWQPdata(siteid=wqpSites$MonitoringLocationIdentifier)
    #assign wqp data and sites to SiteData object
    site@wqpSites <- wqpSites
    site@availableWqpData <- availableWqpData
  }
  return(site)
}#createSiteObject


#'Generates plot based on requested data
#'
#'@param fwsRefuge: sf object containing refuge geomentry
#'@param huc8: sf object containing intersecting huc8 geometry
#'@param huc10: sf object containing intersecting huc10 geometry
generatePlot <- function(fwsRefuge,huc8=NULL,huc10=NULL){
  #create base plot containing refuge geometry
  regionLeaf <- leaflet() %>%
    addProviderTiles("Esri.WorldStreetMap", group="Map") %>%
    addProviderTiles("Esri.WorldImagery", group="Image") %>%
    addPolygons(data=as_Spatial(fwsRefuge,4269), weight=1,fillColor="cyan",
                fillOpacity=0.7,group="Refuge", label= unique(fwsRefuge$ORGNAME))
  overlayGroups <- c("Refuge")
  
  if(!is.null(huc8)){
    #convert huc8 to a polyline (this is to ensure refuge/huc10 layers are not obfuscated)
    huc8 <- st_cast(huc8,"LINESTRING")
    #add converted huc8 polyline to regionLeaf plot
    regionLeaf <- addPolylines(regionLeaf, data=as_Spatial(huc8,4269), color="goldenrod",
                               opacity=0.8,group="HUC8",label=sprintf("HUC8: %s",unique(huc8$NAME)))
    #add huc8 string to overlay groups to be added to layer control
    overlayGroups = c(overlayGroups,"HUC8")
  }
  if(!is.null(huc10)){
    #convert huc10 to polyline
    huc10 <- st_cast(huc10,"LINESTRING")
    #add huc10 to regionLeaf
    regionLeaf <- addPolylines(regionLeaf, data=as_Spatial(huc10,4269),color="blue", weight=2, 
                               opacity=1, group="HUC10",label=sprintf("HUC10: %s",unique(huc10$NAME)))
    #add huc10 to overlay groups
    overlayGroups = c(overlayGroups,"HUC10")
  }
  
  #add layer control to regionLeaf
  regionLeaf <- addLayersControl(regionLeaf,baseGroups=c("Map", "Image"),
                   overlayGroups = overlayGroups,
                   options = layersControlOptions(collapsed=FALSE))
 return(regionLeaf)
}#generatePlot


#' Check to see if warning indicates result directory couldn't be created
#' 
#' @param warning: warnings generated by call to st_write()
#' TODO: Needs wider use cases to cover other potential warnings/errors
isWriteWarning <- function(warning){
  warningText <- conditionMessage(warning)
  dirWarning <- "cannot create dir"
  return(grepl(dirWarning, warningText, fixed=TRUE))
}

#' Write refuge shape file and accompanying data to a given location, creates result folder if it doesn't exist already
#' 
#' @param dat: sf, refuge data obtained from FWS Rest API
#' @param refugeName: char, Name of given refuge
#' @param resultsFolder: char, Path to a location in which to store refuge data
#' TODO: Add code to catch errors when trying to create result folder, hide warnings generated by st_write(),
##' if .shp already exists should it automatically be overwritten?
writeFWSCadastral <- function(dat, refugeName, resultsFolder){
  resultsPath <- sprintf("%s/%s",resultsFolder,refugeName)
  if(is.null(resultsFolder)){
    stop("Please provide a path to folder in which to store results")
    return(dat)
  }
  else if(dir.exists(resultsFolder)) {         #if dir exists
    if(file.access(resultsFolder,2) == 0){    #if R has write permissions
      dir.create(file.path(resultsPath))
      st_write(dat, sprintf("%s/%s_Boundary.shp", 
                            resultsPath, refugeName), delete_dsn=TRUE, quiet = TRUE)   
    }
    else{
      print(sprintf("This program does not have permission to write to %s",resultsFolder))
    }
  }
  else{       #if dir doesn't exist
    tryCatch({
      dir.create(file.path(resultsFolder))
      dir.create(file.path(resultsPath))
    },
    warning = function(w){
      if(isWriteWarning(w)){ 
        print(sprintf("Cannot create/access '%s', please check provided path", resultsFolder))
        stop()
      }
    })
    st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", 
                          resultsPath, refugeName), delete_dsn=TRUE, quiet = TRUE)  
  }
  
}#Write FWSCadastral



#' Obtain intersecting huc8 or huc10 waterbody from USGS Rest API
#' 
#' @param hucLayer: String dictating whether to get huc8 or huc10
#' @param focalSf: Shape file containing site which to obtain interecting waterbodies
#' TODO: Lot's of testing, attempt to find way to query API with polygon rather than
#'       bounding box to remove need to filter out excess HUCs
getHucs <- function(hucLayer, focalSf){
  bbox <- toString(st_bbox(focalSf))
  epsg <- st_crs(focalSf)$epsg
  
  #obtain base url from text doc
  if(hucLayer == "WBDHU8"){
    baseUrl <- readLines("Data/Base_URL.txt")[2]
  }
  else if (hucLayer == "WBDHU10"){
    baseUrl <- readLines("Data/Base_URL.txt")[3]
  }
  
  #append base url to include bounding box of focalSf and set appropriate input and output epsg code
  url <- param_set(baseUrl, key ="geometry", value = URLencode(bbox)) %>%
    param_set(key = "inSR", value = epsg) %>%
    param_set(key = "outSR", value = epsg)
  
  #query rest api
  huc <- read_sf(url)
  #filter out HUCs that do not intersect with focalSf
  huc <- dplyr::filter(huc, lengths(st_intersects(huc,focalSf))>0)
  
  return(huc)
}#getHucs


#' Obtain refuge data from FWS Rest API
#' 
#' @param refugeName: char, Name of desired refuge
#' @param writeResult: boolean, describes whether or not to store obtained data
#' @param resultsFolder: char, path to folder in which to store obtained data
#' TODO: Include check for time out(ie FSW servers are down)
getFWSCadastral <- function(refugeName, approved=FALSE){
  if(nchar(refugeName) < 1){
    stop("Please provide a valid refuge name")
    return(NULL)
  }
  #read in appropriate baseURL based on user input
  if(approved){
    baseUrl <- readLines("Data/base_URL.txt")[4]
  }else{
    baseUrl <- readLines("Data/base_URL.txt")[1]
  }
  #append url to include query info
  url <- param_set(baseUrl, key = "where", value = sprintf("ORGNAME+LIKE+'%s%%25'",gsub(" ","+",refugeName))) %>%
    param_set(key = "outSR", value = 4269)
  #query rest api
  dat <- read_sf(url)    
  #if no data is returned
  if(nrow(dat)==0| is.null(dat)){
    stop("No data returned for this request, please check provided refuge name")
  }
  else{
    return(dat)
  }
  
}#getFWSCadastral


#'returns bounding box of sf features as vector
#'
#' @author: Dr. Ashton Drew
getBoundingBox <- function(sfData, epsg, addBuffer=FALSE, distBuffer=NA){
  # could be polygon, line, point, or mixed geometry
  dat <- sfData 
  if (addBuffer==TRUE){
    dat <- st_as_sf(st_buffer(st_union(dat), dist=distBuffer))
  }
  if (st_crs(dat) != st_crs(epsg)) {
    # Check CRS and transorm if necessary
    dat <- st_transform(dat, crs=epsg)
  }
  # Get bounding box as vector (xmin, ymin, xmax, ymax)
  box <- as.vector(st_bbox(dat, crs=epsg))
}#getBoundingBox

#' Returns NWIS or WQP testing sites in and around a given polygon
#' 
#' @param source: String dictating whether to obtain data from NWIS or WQP
#' @param focalSf: Shapefile containing geometry in which to look for test sites
#' @param bufferSf: Shapefile containing a buffer around the focal sf in which to look for test sites
#' @param bbox: Bounding box of buffer or focalSf if buffer is null
#' @param epsg: CRS used by focalSf
#' @author: Dr. Ashton Drew, Eliot Dixon
getSites <- function(source, focalSf, bufferSf=NULL, bbox, epsg){
  latColName <- "LatitudeMeasure"
  lngColName <- "LongitudeMeasure"
  idColName <- "MonitoringLocationIdentifier"
  #identify NWIS or WQP sites within boundary
  if(source=="NWIS"){
    sitesDf <- whatNWISsites(bBox=round(bbox, 4))
    latColName <- "dec_lat_va"
    lngColName <- "dec_long_va"
    idColName <- "site_no"
  } else {
    sitesDf <- whatWQPsites(bBox=round(bbox, 4))
  }
  # convert located sites to spatial simple features
  sitesSf <- st_as_sf(sitesDf, coords=c(lngColName, latColName), crs=epsg)
  sitesColumns <- names(sitesSf)
  # Identify all sites within focal area and label
  inSites <- st_intersection(sitesSf, st_buffer(focalSf,0)) %>%
    dplyr::select(one_of(sitesColumns)) %>%
    dplyr::mutate(InNear = "In")
  # Identify sites near but outside focal area
  if (!is.null(bufferSf)){
    #Assign all sites within buffer to nearSites
    nearSites <- st_intersection(sitesSf, bufferSf) %>%
      dplyr::select(one_of(sitesColumns)) %>%
      dplyr::mutate(InNear = "Near")
    if (nrow(inSites)>0){
      #filter nearSites so it only contains sites that occur within the buffer and not within focalSf
      nearSites <- dplyr::filter(nearSites, !lengths(st_intersects(nearSites,focalSf))>0)
      allSites <- rbind(inSites, nearSites)
      return(allSites)
    } else {
      allSites <- nearSites
    }
  } else {
    allSites <- inSites
    return(allSites)
  }

}#getSites

tidyWQP <- function(dataDf){
  dataDf <- WqpHucData
  tmp <- dplyr::select(dataDf, one_of("MonitoringLocationIdentifier", "ActivityMediaName", "ActivityStartDate",
                                      "CharacteristicName", "ResultMeasureValue", "ResultMeasure.MeasureUnitCode", "USGSPCode", 
                                      "DetectionQuantitationLimitMeasure.MeasureValue", "ResultDetectionConditionText"))
  names(tmp) <- c("Station", "Media", "StartDate", "CharacteristicName", "ResultValue", "ResultUnit", 
                  "USGSPCode", "DetectLimit", "DetectCondition")
  attr(tmp, 'spec') <- NULL
  tmpSiteInfo <- attr(tmp, 'siteInfo')
  attr(tmp, 'siteInfo') <- NULL
  tmp <- dplyr::left_join(tmp, tmpSiteInfo[,c("site_no", "dec_lat_va", "dec_lon_va")], by=c("Station"="site_no")) %>%
    dplyr::mutate(SourceSet="HUC 8",
                  SourceSet=ifelse(Station %in% unique(huc10WqpSites[["MonitoringLocationIdentifier"]]), "HUC 10", SourceSet),
                  SourceSet=ifelse(Station %in% unique(fwsIntWqpSites[["MonitoringLocationIdentifier"]]), "Refuge", SourceSet),
                  SourceSet=as.factor(SourceSet))
  return(tmp)
}#tidyWQP

#'reads in user input from ReportRequest.csv,ensures logical input is valid, converts char input to logical where possible
readReportRequest <- function(){
  #read in user input
  input <- read.csv("data/ReportRequest.csv",stringsAsFactors = FALSE)
  #for input 2:7 (logical input) convert from type char to logical, ensure input is valid
  for(i in 2:7){
    input[i] <- tolower(input[i])
    if(input[i] == "yes"){
      input[i] = TRUE
    }
    else if(input[i] == "no"){
      input[i] = FALSE
    }
    else{
      stop(sprintf("invalid input in '%s' field, please check ReportRequest.csv in Data folder",names(input)[i]))
    }
  }
  #ensure either input or approved is selected, not both and not neither
  if(!input$Approved& !input$Interest){
    stop("Invalid input, either interest field or approved field must be 'yes', please check ReportRequest.csv in Data folder")
  }else if(input$Approved& input$Interest){
    stop("Invalid input, both interest and approved fields may not be set to 'yes', please check ReportRequest.csv in Data folder")
  }
  return(input)
}#readReportRequest

