wriaLibraries <- function(){
  library(sf)
  library(urltools)
  library(mapview)
  library(stringr)
  library(mapview)
  library(leaflet)
  library(dataRetrieval)
  library(htmltools)
}


#' Abbreviates refuge name
#' 
#' @param refugeName: char, refuge nam
createNameAbbrev <- function(refugeName){
  return(str_replace_all(str_to_title(refugeName), pattern=" ", repl=""))
}


#' Check to see if warning indicates result directory couldn't be created
#' 
#' @param warning: warnings generated by call to st_write()
#' TODO: Needs wider use cases to cover other potential warnings/errors
isWriteWarning <- function(warning){
  warningText <- conditionMessage(warning)
  dirWarning <- "cannot create dir"
  return(grepl(dirWarning, warningText, fixed=TRUE))
}

#' Write refuge data to a given location
#' 
#' @param dat: sf, refuge data obtained from FWS Rest API
#' @param refugeName: char, Name of given refuge
#' @param resultsFolder: char, Path to a location in which to store refuge data
#' TODO: Add code to catch errors when trying to create result folder, hide warnings generated by st_write(),
##' if .shp already exists should it automatically be overwritten?
writeFWSCadastral <- function(dat, refugeName, resultsFolder){
  refugeAbbrev <- createNameAbbrev(refugeName)  
  resultsPath <- sprintf("%s/%s",resultsFolder,refugeAbbrev)
  if(is.null(resultsFolder)){
    print("Please provide a path to folder in which to store results")
    return(dat)
  }
  else if(dir.exists(resultsFolder)) {         #if dir exists
    if(file.access(resultsFolder,2) == 0){    #if R has write permissions
      dir.create(file.path(resultsPath))
      st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", 
                            resultsPath, refugeAbbrev), delete_dsn=TRUE, quiet = TRUE)   
    }
    else{
      print(sprintf("This program does not have permission to write to %s",resultsFolder))
    }
  }
  else{       #if dir doesn't exist
    tryCatch({
      dir.create(file.path(resultsFolder))
      dir.create(file.path(resultsPath))
    },
    warning = function(w){
      if(isWriteWarning(w)){ 
        print(sprintf("Cannot create/access '%s', please check provided path", resultsFolder))
        do.call(return, list(NULL),envir = sys.frame(-4)) #return to getFWSCadastral
      }
    })
    st_write(dat, sprintf("%s/%s_ApprovedBoundary.shp", 
                          resultsPath, refugeAbbrev), delete_dsn=TRUE, quiet = TRUE)  
  }
  
}#Write FWSCadastral

#' Obtain intersecting huc8 or huc10 waterbody from USGS Rest API
#' 
#' @param hucLayer: String dictating whether to get huc8 or huc10
#' @param focalSf: Shape file containing site which to obtain interecting waterbodies
#' TODO: Lot's of testing, attempt to find way to query API with polygon rather than
#'       bounding box to remove need to filter out excess HUCs
getHucs <- function(hucLayer, focalSf){
  baseUrl <- readLines("Data/Base_URL.txt")
  bbox <- toString(st_bbox(focalSf))
  epsg <- st_crs(focalSf)$epsg
  
  if(hucLayer == "WBDHU8"){
    url <- baseUrl[2]
  }
  else if (hucLayer == "WBDHU10"){
    url <- baseUrl[3]
  }
  
  url <- param_set(url, key ="geometry", value = URLencode(bbox)) %>%
    param_set(key = "inSR", value = epsg) %>%
    param_set(key = "outSR", value = epsg)
  
  huc <- read_sf(url)
  huc <- dplyr::filter(huc, lengths(st_intersects(huc,focalSf))>0)
  
  return(huc)
}


#' Obtain refuge data from FWS Rest API
#' 
#' @param refugeName: char, Name of desired refuge
#' @param writeResult: boolean, describes whether or not to store obtained data
#' @param resultsFolder: char, path to folder in which to store obtained data
#' TODO: Include check for time out(ie FSW servers are down)
##' Determine how to handle layerName parameter, and how the layers from .gdb relate to variables in data from Rest API
getFWSCadastral <- function(refugeName, writeResult=FALSE, resultsFolder=NULL){
  if(nchar(refugeName) < 1){ #generate url to query DB
    print("Please provide a valid refuge name")
    return(NULL)
  }
  baseUrl <- readLines("Data/base_URL.txt")
  url <- param_set(baseUrl[1], key = "where", value = sprintf("ORGNAME+LIKE+'%s%%25'",gsub(" ","+",refugeName))) %>%
    param_set(key = "outSR", value = 4269)
  dat <- read_sf(url)    #query db and read into sf obj
  if(nrow(dat)==0| is.null(dat)){
    print("No data returned for this request, please check provided refuge name")
  }
  else{
    if(writeResult == TRUE){
      writeFWSCadastral(dat, refugeName,resultsFolder)
    }
    return(dat)
  }
  
}#getFWSCadastral


#'returns bounding box of sf features as vector
#' @author: Dr. Ashton Drew
getBoundingBox <- function(sfData, epsg, addBuffer=FALSE, distBuffer=NA){
  # could be polygon, line, point, or mixed geometry
  dat <- sfData 
  if (addBuffer==TRUE){
    dat <- st_as_sf(st_buffer(st_union(dat), dist=distBuffer))
  }
  if (st_crs(dat) != st_crs(epsg)) {
    # Check CRS and transorm if necessary
    dat <- st_transform(dat, crs=epsg)
  }
  # Get bounding box as vector (xmin, ymin, xmax, ymax)
  box <- as.vector(st_bbox(dat, crs=epsg))
}


getSites <- function(source, focalSf, bufferSf=NULL, bbox, epsg, latColName, lngColName, idColName){
  # Identify NWIS sites within boundary
  if(source=="NWIS"){
    sitesDf <- whatNWISsites(bBox=round(bbox, 1))
  } else {
    sitesDf <- whatWQPsites(bBox=round(bbox, 1))
  }
  # convert located sites to spatial simple features
  sitesSf <- st_as_sf(sitesDf, coords=c(lngColName, latColName), crs=epsg)
  sitesColumns <- names(sitesSf)
  # Identify all sites within focal area and label
  inSites <- st_intersection(sitesSf, focalSf) %>%
    dplyr::select(one_of(sitesColumns)) %>%
    dplyr::mutate(InNear = "In")
  # Identify sites near but outside focal area
  if (!is.null(bufferSf)){
    nearSites <- st_intersection(sitesSf, bufferSf) %>%
      dplyr::select(one_of(sitesColumns)) %>%
      dplyr::mutate(InNear = "Near")
    if (nrow(inSites)>0){
      nearSites <- st_difference(nearSites, inSites) %>%
        dplyr::select(InNear, one_of(sitesColumns))
      allSites <- rbind(inSites, nearSites)
    } else {
      allSites <- nearSites
    }
  } else {
    allSites <- inSites
    return(allSites)
  }
}

#------------scratch

dat <- getFWSCadastral("WHEELER")
NWIS_Dat <- getSites(source = "NWIS", 
         focalSf = dat, 
         bbox = st_bbox(dat), 
         epsg = st_crs(dat)$epsg, 
         latColName="dec_lat_va", 
         lngColName="dec_long_va",
         idColName="site_no")

NWIS_Buff <- st_as_sf(st_buffer(st_union(dat), dist=0.01))

NWIS_Dat_Buff <- getSites(source = "NWIS", 
                     focalSf = dat, 
                     bbox = st_bbox(dat),
                     bufferSf = NWIS_Buff,
                     epsg = st_crs(dat)$epsg, 
                     latColName="dec_lat_va", 
                     lngColName="dec_long_va",
                     idColName="site_no")

leaflet() %>%
  addProviderTiles("Esri.WorldStreetMap",group="map") %>%
  addCircleMarkers(data = st_as_sf(NWIS_Dat), radius = 5)  %>%
  addCircleMarkers(data = st_as_sf(NWIS_Dat_Buff),radius = 2, color = 'red') %>%
  addPolygons(data = st_as_sf(dat), color = "purple", opacity = .3)
#-------------------------------







checkHucs <- function(refugeName){
  focalSf <- getFWSCadastral(refugeName)
  huc8 <- getHucs("WBDHU8", focalSf)
  huc10 <- getHucs("WBDHU10", focalSf)
  
  leaflet() %>%
    addProviderTiles("Esri.WorldStreetMap", group="Map") %>%
    addProviderTiles("Esri.WorldImagery", group="Image") %>%
    addPolygons(data = as_Spatial(focalSf), stroke=F,fillColor="cyan",fillOpacity=0.7, group="Refuge") %>%
    addPolygons(data=as_Spatial(huc8), fill=F, color="goldenrod",
                opacity=0.8, group="HUC") %>%
    addPolygons(data=as_Spatial(huc10), fill=F, color="red",
                opacity=0.8, group="HUC")
}

#'reads in user input from ReportRequest.csv and ensures logical input is valid
readReportRequest <- function(){
  input <- read.csv("data/ReportRequest.csv",stringsAsFactors = FALSE)
  for(i in 2:7){
    input[i] <- tolower(input[i])
    if(input[i] == "yes"){
      input[i] = TRUE
    }
    else if(input[i] == "no"){
      input[i] = FALSE
    }
    else{
      print(sprintf("invalid input in '%s' field, please check ReportRequest.csv in Data folder",names(input)[i]))
    }
  }
  
  return(input)
  
}



